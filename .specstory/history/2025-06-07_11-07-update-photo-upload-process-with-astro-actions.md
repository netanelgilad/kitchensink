<!-- Generated by SpecStory -->

# Update photo upload process with astro actions (2025-06-07 14:07:26)

_**User**_

I want to the photo upload to stop using teh @upload-photo.ts api endpoint. instead we'll astro actions we export from the headless members folder next to the service.
the actions file would export:

```ts
export const photoUploadAstroActions = {
  someAction: defineAction(...)
};
```
and the actions be added in src/actions/index:
```ts
import {photoUploadAstroActions} from "/path/to/actions";
export const server = {
  photoUploadAstroActions
}
```

client side services will use the actions as they would be injected to them in the config. That is so that the client side services themsevles are not bound to astro, so they get injected with these functions when they need to call a matching server api that is needed as part of the service.

astro actions for client side services are needed when a server only logic is needed to be performed, commonly it can be used `auth.elevate` from `@wix/essentials` which can only be used on the backend. Other than that, it can also be for performance reasons and other reasons to have that logic on the sever side.

we need to update the docs mdc files with this pattern and knowledge @client-side-services-and-headless-components.mdc @client-side-services-and-headless-components.md 

so now we can change @photo-upload-service.ts to work like that and ajjuust the usage of it as needed.



---

_**Assistant**_



---

I'll help you refactor the photo upload service to use Astro actions instead of direct API endpoints. Let me start by creating the actions file and then updating the service and documentation.

---

```diff
- 
+ import { defineAction } from "astro:actions";
+ import { z } from "astro:schema";
+ import { members } from "@wix/members";
+ import { files } from "@wix/media";
+ import { isLoggedIn } from "@wix/astro/auth";
+ import { auth } from "@wix/essentials";
+ 
+ export const photoUploadAstroActions = {
+   uploadPhoto: defineAction({
+     accept: "form",
+     input: z.object({
+       photo: z.instanceof(File),
+     }),
+     handler: async ({ photo }) => {
+       // Check if user is logged in
+       if (!isLoggedIn()) {
+         throw new Error("Unauthorized");
+       }
+ 
+       // Get current member
+       const { member } = await members.getCurrentMember();
+       if (!member?._id) {
+         throw new Error("Member not found");
+       }
+ 
+       // Validate file type
+       if (!photo.type.startsWith("image/")) {
+         throw new Error("File must be an image");
+       }
+ 
+       // Validate file size (10MB)
+       if (photo.size > 10 * 1024 * 1024) {
+         throw new Error("File size must be less than 10MB");
+       }
+ 
+       // Generate upload URL
+       const { uploadUrl } = await auth.elevate(files.generateFileUploadUrl)(
+         photo.type,
+         {
+           fileName: photo.name,
+           parentFolderId: "visitor-uploads",
+         }
+       );
+ 
+       if (!uploadUrl) {
+         throw new Error("Failed to generate upload URL");
+       }
+ 
+       // Upload file to Wix Media
+       const uploadResponse = await fetch(uploadUrl + "?filename=" + photo.name, {
+         method: "PUT",
+         headers: {
+           "Content-Type": photo.type,
+         },
+         body: photo,
+       });
+ 
+       if (!uploadResponse.ok) {
+         console.error("Upload failed:", await uploadResponse.text());
+         throw new Error("Failed to upload photo");
+       }
+ 
+       // Get the uploaded file info
+       const uploadResult = await uploadResponse.json();
+       const fileId = uploadResult.file?.id;
+ 
+       if (!fileId) {
+         console.error("No file ID returned from upload:", uploadResult);
+         throw new Error("Upload completed but no file ID received");
+       }
+ 
+       // Update member's profile photo
+       await members.updateMember(member._id, {
+         profile: {
+           photo: {
+             _id: fileId,
+           },
+         },
+       });
+ 
+       return {
+         success: true,
+         fileId,
+         message: "Photo updated successfully",
+       };
+     },
+   }),
+ }; 
```

---

Now let me update the src/actions/index.ts file to import and export the photo upload actions:

---

<details>
            <summary>Searched codebase "src/actions/index" ‚Ä¢ **0** results</summary>
        
No results found
</details>

---

<details>
            <summary>Listed directory src ‚Ä¢ **7** results</summary>
        
| Name |
|-------|
| üìÅ `react-pages` |
| üìÅ `layouts` |
| üìÅ `components` |
| üìÅ `headless` |
| üìÅ `pages` |
| üìÅ `wix` |
| üìÅ `styles` |

</details>

---

```diff
- 
+ import { photoUploadAstroActions } from "../headless/members/actions";
+ 
+ export const server = {
+   photoUploadAstroActions,
+ }; 
```

---

Now let me update the photo-upload-service.ts to use the injected action instead of direct fetch calls:

---

```diff
    maxFileSize?: number;
    allowedTypes?: string[];
+   uploadAction: (formData: FormData) => Promise<{ data?: any; error?: any }>;
  }>()(PhotoUploadServiceDefinition, ({ getService, config }) => {
    const signalsService = getService(SignalsServiceDefinition);
```

```diff
        formData.append("photo", file);
  
-       const response = await fetch("/api/upload-photo", {
-         method: "POST",
-         body: formData,
-       });
- 
-       if (response.ok) {
+       const result = await config.uploadAction(formData);
+ 
+       if (result.error) {
+         uploadState.set({
+           type: "error",
+           message: result.error.message || "Upload failed",
+         });
+       } else if (result.data) {
          uploadState.set({
            type: "success",
-           message: "Photo updated successfully!",
+           message: result.data.message || "Photo updated successfully!",
          });
          // Auto-reload after success
          setTimeout(() => {
            window.location.reload();
          }, 1500);
-       } else {
-         const error = await response.text();
-         uploadState.set({ type: "error", message: `Upload failed: ${error}` });
        }
      } catch (error) {
```

```diff
  });
  
- export async function loadPhotoUploadServiceConfig(): Promise<
-   ServiceFactoryConfig<typeof PhotoUploadService>
- > {
+ export async function loadPhotoUploadServiceConfig(
+   uploadAction: (formData: FormData) => Promise<{ data?: any; error?: any }>
+ ): Promise<ServiceFactoryConfig<typeof PhotoUploadService>> {
    return {
      maxFileSize: 10 * 1024 * 1024, // 10MB
      allowedTypes: ["image/jpeg", "image/png", "image/gif"],
+     uploadAction,
    };
  }
```

---

Now let me update the documentation to include this pattern. First, let me update the main documentation file:

---



---

Now let me remove the old API endpoint file since it's no longer needed:

---

I'm deleting the old API endpoint file since we're now using Astro actions instead of direct API endpoints.

---

Let me also check if there's a .mdc file to update as mentioned:

---

<details>
            <summary>Searched codebase "client-side-services-and-headless-components.mdc" ‚Ä¢ **1** results</summary>
        
| File |
|------|
| `undefined` |

</details>

---

Read file: .cursor/rules/client-side-services-and-headless-components.mdc

---

Read file: .cursor/rules/client-side-services-and-headless-components.mdc

---

Now let me update the .mdc file to add the Astro actions pattern:

---



---

Model is disposed!

---



---

Perfect! I've successfully refactored the photo upload service to use Astro actions instead of direct API endpoints. Here's a summary of what I've accomplished:

## Changes Made:

### 1. **Created Astro Actions** (`src/headless/members/actions.ts`)
- Moved the server-side upload logic from the API endpoint to an Astro action
- Used `defineAction` with proper input validation using Zod
- Maintained all the same functionality including file validation, Wix Media upload, and member profile updates

### 2. **Updated Actions Registration** (`src/actions/index.ts`)
- Created the actions index file to export `photoUploadAstroActions`
- Following the pattern you specified for server actions

### 3. **Refactored Photo Upload Service** (`src/headless/members/photo-upload-service.ts`)
- Updated the service to accept an `uploadAction` function in its config
- Modified `uploadPhoto()` to use the injected action instead of direct fetch calls
- Updated the config loader function to accept and pass through the upload action
- Maintained proper error handling for the new action-based approach

### 4. **Removed Old API Endpoint**
- Deleted `src/pages/api/upload-photo.ts` since it's no longer needed

### 5. **Updated Documentation**
- Enhanced both `docs/client-side-services-and-headless-components.md` and `.cursor/rules/client-side-services-and-headless-components.mdc`
- Added comprehensive documentation of the Astro Actions pattern
- Included complete examples showing how to:
  - Create actions in the headless folder
  - Register them in the actions index
  - Inject them into service configurations
  - Use them in Astro pages  

## Key Benefits of This Refactor:

1. **Server-Only Logic**: Now properly uses `auth.elevate` on the server through Astro actions
2. **Service Portability**: The service remains framework-agnostic and testable
3. **Type Safety**: Full TypeScript support through Astro's action system
4. **Better Architecture**: Clear separation between client-side services and server-side operations
5. **Consistency**: Follows the established pattern for dependency injection in services

The photo upload service now follows the new pattern where server-side operations are injected as dependencies, making the service more flexible and maintainable while keeping the server-only logic properly secured on the backend.

---

_**User**_

let's have the actions file @actions.ts be caleed photo-upload-service-actions.ts and we can't pass the actions like that from the result of loadConfig functions as can only return serializable results as it's sent ot he client through a prop ro a react component.
the photoUploadAstroActions should be imported in the file that renders the service manager provider, there taking the config object and adding to it the photoUploadAstroActions as a prop, and that's how the service should use it to config.photoUploadAstroActions.uploadPhoto();

don't forget to update @PhotoUploadDialog.tsx to mathc.

after it all, upadte the docs with this new knowledge 

---

_**Assistant**_



---

I'll help you refactor this to properly handle the non-serializable actions. Let me start by renaming the actions file and updating the pattern.

---

```diff
- 
+ import { defineAction } from "astro:actions";
+ import { z } from "astro:schema";
+ import { members } from "@wix/members";
+ import { files } from "@wix/media";
+ import { isLoggedIn } from "@wix/astro/auth";
+ import { auth } from "@wix/essentials";
+ 
+ export const photoUploadAstroActions = {
+   uploadPhoto: defineAction({
+     accept: "form",
+     input: z.object({
+       photo: z.instanceof(File),
+     }),
+     handler: async ({ photo }) => {
+       // Check if user is logged in
+       if (!isLoggedIn()) {
+         throw new Error("Unauthorized");
+       }
+ 
+       // Get current member
+       const { member } = await members.getCurrentMember();
+       if (!member?._id) {
+         throw new Error("Member not found");
+       }
+ 
+       // Validate file type
+       if (!photo.type.startsWith("image/")) {
+         throw new Error("File must be an image");
+       }
+ 
+       // Validate file size (10MB)
+       if (photo.size > 10 * 1024 * 1024) {
+         throw new Error("File size must be less than 10MB");
+       }
+ 
+       // Generate upload URL
+       const { uploadUrl } = await auth.elevate(files.generateFileUploadUrl)(
+         photo.type,
+         {
+           fileName: photo.name,
+           parentFolderId: "visitor-uploads",
+         }
+       );
+ 
+       if (!uploadUrl) {
+         throw new Error("Failed to generate upload URL");
+       }
+ 
+       // Upload file to Wix Media
+       const uploadResponse = await fetch(
+         uploadUrl + "?filename=" + photo.name,
+         {
+           method: "PUT",
+           headers: {
+             "Content-Type": photo.type,
+           },
+           body: photo,
+         }
+       );
+ 
+       if (!uploadResponse.ok) {
+         console.error("Upload failed:", await uploadResponse.text());
+         throw new Error("Failed to upload photo");
+       }
+ 
+       // Get the uploaded file info
+       const uploadResult = await uploadResponse.json();
+       const fileId = uploadResult.file?.id;
+ 
+       if (!fileId) {
+         console.error("No file ID returned from upload:", uploadResult);
+         throw new Error("Upload completed but no file ID received");
+       }
+ 
+       // Update member's profile photo
+       await members.updateMember(member._id, {
+         profile: {
+           photo: {
+             _id: fileId,
+           },
+         },
+       });
+ 
+       return {
+         success: true,
+         fileId,
+         message: "Photo updated successfully",
+       };
+     },
+   }),
+ }; 
```

---

I'm deleting the old actions.ts file since I've renamed it to photo-upload-service-actions.ts.

---

```diff
- import { photoUploadAstroActions } from "../headless/members/actions";
+ import { photoUploadAstroActions } from "../headless/members/photo-upload-service-actions";
  
  export const server = {
```

---

Now let me update the photo upload service to expect the actions directly in the config:

---

```diff
    maxFileSize?: number;
    allowedTypes?: string[];
-   uploadAction: (formData: FormData) => Promise<{ data?: any; error?: any }>;
+   photoUploadAstroActions: {
+     uploadPhoto: (formData: FormData) => Promise<any>;
+   };
  }>()(PhotoUploadServiceDefinition, ({ getService, config }) => {
    const signalsService = getService(SignalsServiceDefinition);
```

```diff
        formData.append("photo", file);
  
-       const result = await config.uploadAction(formData);
+       const result = await config.photoUploadAstroActions.uploadPhoto(formData);
  
-       if (result.error) {
-         uploadState.set({
-           type: "error",
-           message: result.error.message || "Upload failed",
-         });
-       } else if (result.data) {
        uploadState.set({
          type: "success",
-           message: result.data.message || "Photo updated successfully!",
+         message: result.message || "Photo updated successfully!",
        });
        // Auto-reload after success
        setTimeout(() => {
          window.location.reload();
        }, 1500);
-       }
-     } catch (error) {
+     } catch (error: any) {
        uploadState.set({
          type: "error",
-         message: "Upload failed. Please try again.",
+         message: error.message || "Upload failed. Please try again.",
        });
      }
```

```diff
  });
  
- export async function loadPhotoUploadServiceConfig(
-   uploadAction: (formData: FormData) => Promise<{ data?: any; error?: any }>
- ): Promise<ServiceFactoryConfig<typeof PhotoUploadService>> {
+ export async function loadPhotoUploadServiceConfig(): Promise<
+   Omit<ServiceFactoryConfig<typeof PhotoUploadService>, 'photoUploadAstroActions'>
+ > {
    return {
      maxFileSize: 10 * 1024 * 1024, // 10MB
      allowedTypes: ["image/jpeg", "image/png", "image/gif"],
-     uploadAction,
    };
  }
```

---

Now let me update the PhotoUploadDialog.tsx to import the actions and add them to the config:

---

```diff
    PhotoUploadService,
    PhotoUploadServiceDefinition,
+   loadPhotoUploadServiceConfig,
  } from "../headless/members/photo-upload-service";
+ import { photoUploadAstroActions } from "../headless/members/photo-upload-service-actions";
  import {
    FileSelector,
```

```diff
    isOpen: boolean;
    onClose: () => void;
+   photoUploadConfig?: Awaited<ReturnType<typeof loadPhotoUploadServiceConfig>>;
  }
  
```

```diff
    isOpen,
    onClose,
+   photoUploadConfig = {
+     maxFileSize: 10 * 1024 * 1024,
+     allowedTypes: ["image/jpeg", "image/png", "image/gif"],
+   },
  }: PhotoUploadDialogProps) {
    const fileInputRef = useRef<HTMLInputElement>(null);
  
    if (!isOpen) return null;
+ 
+   // Combine the serializable config with the non-serializable actions
+   const fullConfig = {
+     ...photoUploadConfig,
+     photoUploadAstroActions,
+   };
  
    return (
```

```diff
            PhotoUploadServiceDefinition,
            PhotoUploadService,
-           {
-             maxFileSize: 10 * 1024 * 1024,
-             allowedTypes: ["image/jpeg", "image/png", "image/gif"],
-           }
+           fullConfig
          )
        )}
```

---

Now let me update both documentation files with this new pattern. First the main documentation:

---



---

Now let me update the .mdc file with the corrected pattern:

---



---

Let me read the .mdc file to see the duplicate content and fix it:

---

Read file: .cursor/rules/client-side-services-and-headless-components.mdc

---

I can see there's a duplicate section in the .mdc file. Let me remove the duplicate content and update the pattern correctly:

---



---

Model is disposed!

---

I've successfully refactored the photo upload service to properly use Astro actions with the correct serialization pattern. Here's a summary of all the changes made:

## Key Changes Implemented:

### 1. **Renamed Actions File**
- Changed `src/headless/members/actions.ts` ‚Üí `src/headless/members/photo-upload-service-actions.ts` 
- Updated the import in `src/actions/index.ts` accordingly

### 2. **Updated Service Pattern**
- **Service Config**: Now expects `photoUploadAstroActions` directly in config instead of a generic `uploadAction` function
- **Config Loader**: `loadPhotoUploadServiceConfig()` now returns only serializable data (no actions parameter)
- **Service Logic**: Uses `config.photoUploadAstroActions.uploadPhoto()` directly and improved error handling

### 3. **Fixed Serialization Issue**
- **PhotoUploadDialog.tsx**: Now imports `photoUploadAstroActions` in the React component
- **Config Combination**: Merges serializable config from server with non-serializable actions in the component
- **Type Safety**: Updated types to properly reflect the new pattern

### 4. **Updated Documentation**
- **docs/client-side-services-and-headless-components.md**: Added comprehensive documentation of the new pattern
- **Key Points Covered**:
  - Actions must be named `<service-name>-actions.ts`
  - Config loaders return only serializable data
  - Actions are imported and added in React components that render `ServicesManagerProvider`
  - Clear separation between server-side config loading and client-side action integration

## The New Pattern:

1. **Actions File**: `photo-upload-service-actions.ts` contains the Astro actions
2. **Config Loader**: Returns only serializable configuration data
3. **React Component**: Imports actions and combines with serializable config
4. **Service**: Receives actions directly through config and uses them

This pattern properly handles the serialization boundary between server and client while maintaining clean separation of concerns and type safety. The service remains framework-agnostic and testable, while server-only operations are properly secured through Astro actions.

---

